# 자료구조 기본 개념

## 점근 표기법

- f(n) : 알고리즘의 성능(복잡도)
- O (빅 오) : 상한 표기법, f(n) = O(g(n)), 점근적 상한
  - 모든 n (n ≥ k) 에 대해 0 ≤ f(n) ≤ c\*g(n) 인 조건을 만족하는 c와 k가 존재하기만 하면 f(n) = O(g(n))이다.
  - f(n)은 항상 g(n)보다 같거나 작다.
  - f(n)함수의 결과치가 g(n)함수의 것보다 클 수 없다.
- Ω (빅 오메가) : 하한 표기법, f(n) = Ω(g(n)), 점근적 하한
  - 모든 n (n ≥ k) 에 대해 c\*g(n) ≤ f(n) 인 조건을 만족하는 c와 k가 존재하기만 하면 f(n) = Ω(g(n))이다.
  - f(n)이 아무리 작아도, g(n)보다는 크거나 같다.
- Θ (빅 세타) : 점근적 상한 및 하한, f(n) = Θ(g(n)), 상한과 하한이 같은지 아닌지를 결정
  - 모든 n (n ≥ k) 에 대해 c1g(n) ≤ f(n) ≤ c2g(n) 인 조건을 만족하는 c1, c2와 k가 존재하기만 하면 f(n) = Θ(g(n))이다.
  - f(n)은 최선의 경우나, 최악의 경우라도 g(n)범위 내에 있다.

### 사용 목적

- 점근 표기법은 알고리즘의 성능을 수학적으로 표기하는 방법이며, 실행 시간에 영향을 미치는 주요 요인을 특징화할 수 있다.
- 알고리즘의 계산 복잡성 증가 양상을 단순화 시켜서 수식으로 표현하는 것이다.
- 보통 O (빅 오) 표기법을 많이 사용한다.

### 추상 데이터 타입(ADT)

### 시간 복잡도

- 특정 크기의 입력을 기준으로 할 때 필요한 연산의 횟수
- 함수의 실행 시간을 표현하는 것
- 주로 점근적 분석을 통해 실행 시간을 단순하게 표현하며, 점근적 표기법으로 표현

### 공간 복잡도

- 프로그램 실행과 완료에 얼마나 많은 공간(메모리)가 필요한지를 나타낸다.
- 알고리즘을 실행시키기 위한 필요한 공간은 두 가지 이다.
  - 고정 공간 : 알고리즘과 무관한 코드가 저장되는 공간, 실행을 위해 시스템이 필요로 하는 공간 등
  - 가변 공간 : 문제를 해결하기 위한 알고리즘이 필요로 하는 공간, 변수, 순환 스택 등

### 코드 구현(선택)

```js
const test = [1, 2, 3, 4, 5, 6, 7, 8, 9];
let count = 0;

for (let i = 0; i < test.length; i++) {
  // c1 : N+1 번 (마지막으로 루프 검사)
  count += i; // c2 : N 번
}

return count; // c3 : 1 번

// 시간 복잡도는 N+N+1+1 = 2N+2, (a*N+b), O(N)
```

# 알고리즘

## 2. 버블 정렬

- 인접한 두 원소를 비교해 나가며 가장 큰 원소를 끝으로 보내는 과정을 N-1번 반복하는 알고리즘이다.
- 데이터가 적을 때 사용하는 것이 좋다.
- 안정 정렬이다(동일한 값의 상대적 순서를 유지).

### 시간 복잡도

- 버블 정렬은 외부 루프를 N-1번 반복하는 동안, N-1, N-2, N-3,.., 1번 인접한 원소들을 비교한다.
- T(n) = (n-1)+(n-2)+(n-3)+...+1 = (n-1)\*n/2 시간복잡도는 O(n) = n^2 이다.

### 코드 구현

```js
const arr = [1, 6, 3, 5, 7, 4, 9, 8, 2];
arr.push(10);

function bubbleSort(arr) {
  let n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}
```

## 3. 선택 정렬

- N-1번부터 1번까지의 자리에 대하여 해당 자리에 넣어야 하는 원소를 선택하는 알고리즘이다.
- 오름차순으로 정렬한다면, N-1번부터 1번까지의 자리에는 남아있는 수들 중 가장 큰 수를 선택하여 넣어야 한다.
- 불안정 정렬로, 동일한 값의 상대적 순서를 유지하지 않는다.
- 단순한 구현에 사용하며 제자리 정렬이므로 메모리가 제한된 경우 추가 메모리 사용이 없다.

### 시간 복잡도

- 외부의 루프를 (N-1)번 도는 동안, 각 자리에 와야하는 최댓값을 구하기 위하여 N-1, N-2, N-3,.., 1번의 비교연산을 수행한다.
- T(n) = (n-1)+(n-2)+(n-3)+...+1 = (n-1)\*n/2 시간복잡도는 O(n) = n^2 이다.

### 코드 구현

```js
const arr = [1, 6, 3, 5, 7, 4, 9, 8, 2];
arr.push(10);

function selectionSort(arr) {
  let n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    let minIndex = i;
    for (let j = i + 1; j < n; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    if (minIndex !== i) {
      let temp = arr[i];
      arr[i] = arr[minIndex];
      arr[minIndex] = temp;
    }
  }
  return arr;
}
```

## 4. 삽입 정렬

- 새로운 원소를 이전까지 정렬된 원소 사이에 올바르게 삽입시키는 알고리즘이다.
- 새로운 원소를 올바른 위치에 삽입시켜나가는 과정을 모든 원소에 대해 수행하면 정렬이 완성된다.
- 안정 정렬이다.
- 다음과 같은 상황에서 사용한다.
  - 데이터가 이미 거의 다 정렬되어 있는 경우.
  - 데이터가 작을 경우
  - 데이터가 실시간으로 들어올 경우

### 시간 복잡도

- 모든 원소가 이미 정렬이 되어있는 경우, 외부 루프를 N-1번 도는 동안 비교 연산은 1번씩 수행된다.
- 따라서 최선의 경우, Best T(n) = (N-1)\*1 즉, O(n) = n 이 된다.
- 모든 원소가 역순으로 정렬되어 있는 경우, 외부 루프를 N-1번 도는 동안 비교연산은 1, 2,.., (N-1)번 수행된다.
- 따라서 최악의 경우, Worst T(n) = 1+2+...+(N-1) = (N-1)\*N/2 즉, O(n) = n^2 이 된다.

### 코드 구현

```js
const arr = [1, 6, 3, 5, 7, 4, 9, 8, 2];
arr.push(10);

function insertionSort(arr) {
  let n = arr.length;
  for (let i = 1; i < n; i++) {
    let key = arr[i];
    let j = i - 1;
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j];
      j = j - 1;
    }
    arr[j + 1] = key;
  }
  return arr;
}
```
